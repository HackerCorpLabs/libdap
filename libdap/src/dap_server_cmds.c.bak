/**
 * @file dap_server_cmds.c
 * @brief Server implementation for the DAP library
 */

#include <stdarg.h> // For va_list, va_start, va_end
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>

#include "dap_server.h"
#include "dap_error.h"
#include "dap_types.h"
#include "dap_transport.h"
#include "dap_protocol.h"
#include "dap_server_cmds.h"
#include <cjson/cJSON.h>

// Define status flags for the status register
static StatusFlag status_flags[] = {
    {"PTM", false, "flag"},  // Page Table Flag
    {"TG", false, "flag"},   // Floating point rounding flag
    {"K", false, "flag"},    // Accumulator
    {"Z", false, "flag"},    // Error flag
    {"Q", false, "flag"},    // Dynamic overflow flag
    {"O", false, "flag"},    // Static overflow flag
    {"C", false, "flag"},    // Carry flag
    {"M", false, "flag"},    // Multi-shift link flag
    {"PIL", false, "level"}, // Program Level (4 bits) - changed to bool for compatibility
    {"N100", true, "flag"},  // ND-100 flag (always 1)
    {"SEXI", false, "flag"}, // Memory management extended mode
    {"PONI", false, "flag"}, // Memory management ON flag
    {"IONI", false, "flag"}  // Interrupt system ON flag
};

#define NUM_STATUS_FLAGS (sizeof(status_flags) / sizeof(StatusFlag))

// Define CPU registers for ND-100
static Register cpu_registers[] = {
    {"STS", 0x0000, "bitmask", true, 1001}, // Status register with nested flags
    {"D", 0x0000, "integer", false, 0},     // Data register
    {"P", 0x1000, "integer", false, 0},     // Program counter
    {"B", 0x0000, "integer", false, 0},     // Base register
    {"L", 0x0000, "integer", false, 0},     // Link register
    {"A", 0x0000, "integer", false, 0},     // Accumulator
    {"T", 0x0000, "integer", false, 0},     // Temporary register
    {"X", 0x0000, "integer", false, 0}      // Index register
};

#define NUM_REGISTERS (sizeof(cpu_registers) / sizeof(Register))

// Define internal registers for read
static Register internal_read_registers[] = {
    {"PANC", 0x0000, "octal", false, 0}, // Panel control
    {"STS", 0x0001, "octal", false, 0},  // Status register
    {"LMP", 0x0002, "octal", false, 0},  // Panel data display buffer register
    {"PCR", 0x0003, "octal", false, 0},  // Paging control register
    {"IIE", 0x0005, "octal", false, 0},  // Internal interrupt enable register
    {"PID", 0x0006, "octal", false, 0},  // Priority interrupt detect register
    {"PIE", 0x0007, "octal", false, 0},  // Priority interrupt enable register
    {"CCL", 0x0010, "octal", false, 0},  // Cache clear register
    {"LCIL", 0x0011, "octal", false, 0}, // Lower cache inhibit limit register
    {"UCIL", 0x0012, "octal", false, 0}, // Upper cache inhibit limit register
    {"CILP", 0x0013, "octal", false, 0}, // Cache inhibit page register
    {"ECCR", 0x0015, "octal", false, 0}, // Error correction control register
    {"CS", 0x0017, "octal", false, 0}    // Control Store
};

#define NUM_INTERNAL_READ_REGISTERS (sizeof(internal_read_registers) / sizeof(Register))

// Define internal registers for write
static Register internal_write_registers[] = {
    {"PANS", 0x0000, "octal", false, 0}, // Panel status
    {"STS", 0x0001, "octal", false, 0},  // Status register
    {"OPR", 0x0002, "octal", false, 0},  // Operator's panel switch register
    {"PSR", 0x0003, "octal", false, 0},  // Paging status register
    {"PVL", 0x0004, "octal", false, 0},  // Previous level code register
    {"IIC", 0x0005, "octal", false, 0},  // Internal interrupt code register
    {"PID", 0x0006, "octal", false, 0},  // Priority interrupt detect register
    {"PIE", 0x0007, "octal", false, 0},  // Priority enable detect register
    {"CSR", 0x0010, "octal", false, 0},  // Cache status register
    {"ACTL", 0x0011, "octal", false, 0}, // Active level register
    {"ALD", 0x0012, "octal", false, 0},  // Automatic load descriptor
    {"PES", 0x0013, "octal", false, 0},  // Parity error status register
    {"PGC", 0x0014, "octal", false, 0},  // Paging control register
    {"PEA", 0x0015, "octal", false, 0},  // Parity error address register
    {"CS", 0x0017, "octal", false, 0}    // Control store
};

#define NUM_INTERNAL_WRITE_REGISTERS (sizeof(internal_write_registers) / sizeof(Register))

void set_response_success(DAPResponse *response, cJSON *body)
{
    if (response)
    {
        response->success = true;
        response->error_message = NULL;
        if (body)
        {
            response->data = cJSON_PrintUnformatted(body);
            response->data_size = strlen(response->data);
            // Free the body after using it to avoid memory leaks
            cJSON_Delete(body);
        }
        else
        {
            response->data = NULL;
            response->data_size = 0;
        }
    }
}

// Helper functions for response handling
void set_response_error(DAPResponse *response, const char *error_message)
{
    if (response)
    {
        response->success = false;
        response->error_message = strdup(error_message);
        response->data = NULL;
        response->data_size = 0;
    }
}

/**
 * @brief Send the 'initialized' event to the client
 * This event should be sent after the successful response to an 'initialize' request
 * @param server Server instance
 * @return 0 on success, non-zero on failure
 */
int send_initialized_event(DAPServer *server)
{
    if (!server)
    {
        return -1;
    }

    // Create empty body - the initialized event doesn't need any additional data
    cJSON *body = cJSON_CreateObject();
    if (!body)
    {
        return -1;
    }

    // Send the event
    int result = dap_server_send_event(server, "initialized", body);
    
    // Clean up
    cJSON_Delete(body);
    
    return result;
}

/**
 * @brief Structure representing a single server capability
 */
typedef struct {
    const char *name;     // Name of the capability in the DAP spec
    bool supported;       // Whether the capability is supported
} DAPCapability;

/**
 * @brief Global array of server capabilities
 * Indexed by DAPCapabilityID enum values
 * All capabilities are initialized as false by default
 */
static DAPCapability server_capabilities[DAP_CAP_COUNT] = {
    {"supportsConfigurationDoneRequest",      false},
    {"supportsFunctionBreakpoints",           false},
    {"supportsConditionalBreakpoints",        false},
    {"supportsHitConditionalBreakpoints",     false},
    {"supportsEvaluateForHovers",             false},
    {"supportsSetVariable",                   false},
    {"supportsCompletionsRequest",            false},
    {"supportsModulesRequest",                false},
    {"supportsRestartRequest",                false},
    {"supportsExceptionOptions",              false},
    {"supportsValueFormattingOptions",        false},
    {"supportsExceptionInfoRequest",          false},
    {"supportTerminateDebuggee",              false},  // NOTE! This is not the same as terminateRequest. And be aware of the single vs plural in the name. Its single!
    {"supportsDelayedStackTraceLoading",      false},
    {"supportsLoadedSourcesRequest",          false},
    {"supportsLogPoints",                     false},
    {"supportsTerminateThreadsRequest",       false},
    {"supportsSetExpression",                 false},
    {"supportsTerminateRequest",              false},
    {"supportsDataBreakpoints",               false},
    {"supportsReadMemoryRequest",             false},
    {"supportsWriteMemoryRequest",            false},
    {"supportsDisassembleRequest",            false},
    {"supportsCancelRequest",                 false},
    {"supportsBreakpointLocationsRequest",    false},
    {"supportsSteppingGranularity",           false},
    {"supportsInstructionBreakpoints",        false},
    {"supportsExceptionFilterOptions",        false},
    {"supportsSingleThreadExecutionRequests", false},
    {"supportsStepBack",                      false},
    {"supportsRestartFrame",                  false},
    {"supportsGotoTargetsRequest",            false},
    {"supportsStepInTargetsRequest",          false},
    {"supportsClipboardContext",              false},
};

/**
 * @brief Set a capability in the capability array
 * 
 * @param capability_id The capability enum value to set
 * @param supported Whether the capability is supported
 * @return int 0 on success, -1 if capability_id is out of range
 */
int dap_server_set_capability(DAPCapabilityID capability_id, bool supported)
{
    if (capability_id >= 0 && capability_id < DAP_CAP_COUNT) {
        server_capabilities[capability_id].supported = supported;
        return 0;
    }
    return -1;
}

/**
 * @brief Enum for DAP exception filter types
 * 
 * Per DAP specification, an ExceptionBreakpointsFilter represents a specific way of handling 
 * exceptions that can be enabled or disabled by the client. Each filter is shown in the UI
 * as a checkbox option for configuring how exceptions are dealt with during debugging.
 */
typedef enum {
    DAP_EXC_FILTER_ALL,      // Breaks when any exception is thrown, whether caught or not
    DAP_EXC_FILTER_UNCAUGHT, // Breaks only on exceptions that aren't caught by user code
    
    // Keep this last to get the total count of filters
    DAP_EXC_FILTER_COUNT
    
    /* To add new exception filters:
     * 1. Add a new enum value above DAP_EXC_FILTER_COUNT
     * 2. Add a corresponding entry in the exception_filters array
     */
} DAPExceptionFilterID;

/**
 * @brief Structure representing an exception breakpoint filter
 * 
 * According to DAP spec, these filters are exposed to the client during initialization 
 * as part of the 'exceptionBreakpointFilters' capability. The client UI shows each filter
 * as an option that can be enabled/disabled. When enabled, the debug adapter will break
 * execution when exceptions matching the filter criteria are thrown.
 */
typedef struct {
    const char *id;          // Filter ID used in requests (matches the filter in enum)
    const char *label;       // Human-readable filter name shown in the UI
    const char *description; // Description of when this filter applies
    bool default_value;      // Whether this filter is enabled by default
} DAPExceptionFilter;

/**
 * @brief Global array of exception filters
 * Indexed by DAPExceptionFilterID enum values
 */
static const DAPExceptionFilter exception_filters[DAP_EXC_FILTER_COUNT] = {
    {"all",      "All Exceptions",       "Break on all exceptions",           false},
    {"uncaught", "Uncaught Exceptions",  "Break on uncaught exceptions",      true},
};

/// @brief Handle the DAP initialize command
/// @param server
/// @param args
/// @param response
/// @return
int handle_initialize(DAPServer *server, cJSON *args, DAPResponse *response)
{
    if (!response || !server)
    {
        return -1;
    }

    // Store client capabilities if provided
    if (args)
    {
        // Parse and store important client capabilities
        cJSON *client_id = cJSON_GetObjectItem(args, "clientID");
        if (client_id && cJSON_IsString(client_id)) {
            if (server->client_capabilities.clientID) {
                free(server->client_capabilities.clientID);
            }
            server->client_capabilities.clientID = strdup(client_id->valuestring);
        }
        
        cJSON *client_name = cJSON_GetObjectItem(args, "clientName");
        if (client_name && cJSON_IsString(client_name)) {
            if (server->client_capabilities.clientName) {
                free(server->client_capabilities.clientName);
            }
            server->client_capabilities.clientName = strdup(client_name->valuestring);
        }
        
        cJSON *adapter_id = cJSON_GetObjectItem(args, "adapterID");
        if (adapter_id && cJSON_IsString(adapter_id)) {
            if (server->client_capabilities.adapterID) {
                free(server->client_capabilities.adapterID);
            }
            server->client_capabilities.adapterID = strdup(adapter_id->valuestring);
        }
        
        cJSON *locale = cJSON_GetObjectItem(args, "locale");
        if (locale && cJSON_IsString(locale)) {
            if (server->client_capabilities.locale) {
                free(server->client_capabilities.locale);
            }
            server->client_capabilities.locale = strdup(locale->valuestring);
        }
        
        // Store path format (path or uri)
        cJSON *path_format = cJSON_GetObjectItem(args, "pathFormat");
        if (path_format && cJSON_IsString(path_format)) {
            if (server->client_capabilities.pathFormat) {
                free(server->client_capabilities.pathFormat);
            }
            server->client_capabilities.pathFormat = strdup(path_format->valuestring);
        }
        
        // Store line/column formatting preferences
        cJSON *lines_start_at_1 = cJSON_GetObjectItem(args, "linesStartAt1");
        if (lines_start_at_1 && cJSON_IsBool(lines_start_at_1)) {
            server->client_capabilities.linesStartAt1 = cJSON_IsTrue(lines_start_at_1);
        } else {
            server->client_capabilities.linesStartAt1 = true; // Default to 1-based
        }
        
        cJSON *columns_start_at_1 = cJSON_GetObjectItem(args, "columnsStartAt1");
        if (columns_start_at_1 && cJSON_IsBool(columns_start_at_1)) {
            server->client_capabilities.columnsStartAt1 = cJSON_IsTrue(columns_start_at_1);
        } else {
            server->client_capabilities.columnsStartAt1 = true; // Default to 1-based
        }
        
        // Store supported client features
        cJSON *supports_variable_type = cJSON_GetObjectItem(args, "supportsVariableType");
        if (supports_variable_type && cJSON_IsBool(supports_variable_type)) {
            server->client_capabilities.supportsVariableType = cJSON_IsTrue(supports_variable_type);
        }
        
        cJSON *supports_variable_paging = cJSON_GetObjectItem(args, "supportsVariablePaging");
        if (supports_variable_paging && cJSON_IsBool(supports_variable_paging)) {
            server->client_capabilities.supportsVariablePaging = cJSON_IsTrue(supports_variable_paging);
        }
        
        cJSON *supports_run_in_terminal = cJSON_GetObjectItem(args, "supportsRunInTerminalRequest");
        if (supports_run_in_terminal && cJSON_IsBool(supports_run_in_terminal)) {
            server->client_capabilities.supportsRunInTerminalRequest = cJSON_IsTrue(supports_run_in_terminal);
        }
        
        cJSON *supports_memory_references = cJSON_GetObjectItem(args, "supportsMemoryReferences");
        if (supports_memory_references && cJSON_IsBool(supports_memory_references)) {
            server->client_capabilities.supportsMemoryReferences = cJSON_IsTrue(supports_memory_references);
        }
        
        cJSON *supports_progress_reporting = cJSON_GetObjectItem(args, "supportsProgressReporting");
        if (supports_progress_reporting && cJSON_IsBool(supports_progress_reporting)) {
            server->client_capabilities.supportsProgressReporting = cJSON_IsTrue(supports_progress_reporting);
        }
        
        cJSON *supports_invalidated_event = cJSON_GetObjectItem(args, "supportsInvalidatedEvent");
        if (supports_invalidated_event && cJSON_IsBool(supports_invalidated_event)) {
            server->client_capabilities.supportsInvalidatedEvent = cJSON_IsTrue(supports_invalidated_event);
        }
        
        cJSON *supports_memory_event = cJSON_GetObjectItem(args, "supportsMemoryEvent");
        if (supports_memory_event && cJSON_IsBool(supports_memory_event)) {
            server->client_capabilities.supportsMemoryEvent = cJSON_IsTrue(supports_memory_event);
        }

        cJSON *supports_ansi_styling = cJSON_GetObjectItem(args, "supportsANSIStyling");
        if (supports_ansi_styling && cJSON_IsBool(supports_ansi_styling)) {
            server->client_capabilities.supportsANSIStyling = cJSON_IsTrue(supports_ansi_styling);
        }
        
        cJSON *supports_args_shell = cJSON_GetObjectItem(args, "supportsArgsCanBeInterpretedByShell");
        if (supports_args_shell && cJSON_IsBool(supports_args_shell)) {
            server->client_capabilities.supportsArgsCanBeInterpretedByShell = cJSON_IsTrue(supports_args_shell);
        }
        
        cJSON *supports_start_debugging = cJSON_GetObjectItem(args, "supportsStartDebuggingRequest");
        if (supports_start_debugging && cJSON_IsBool(supports_start_debugging)) {
            server->client_capabilities.supportsStartDebuggingRequest = cJSON_IsTrue(supports_start_debugging);
        }

        // Log the client information
        DAP_SERVER_DEBUG_LOG("Initialized with client: %s (%s)", 
            server->client_capabilities.clientName ? server->client_capabilities.clientName : "unknown",
            server->client_capabilities.clientID ? server->client_capabilities.clientID : "unknown");
    }

    // Create the response with our capabilities
    cJSON *capabilities = cJSON_CreateObject();
    if (!capabilities)
    {
        set_response_error(response, "Failed to create capabilities object");
        return -1;
    }

    // Add supported capabilities to the response
    for (int i = 0; i < DAP_CAP_COUNT; i++) {
        if (server_capabilities[i].supported)
         {
            cJSON_AddBoolToObject(capabilities, server_capabilities[i].name, true);
        }
    }

    // Create and add exception filters
    cJSON *exceptionFilters = cJSON_CreateArray();
    if (exceptionFilters)
    {
        // Add all defined exception filters
        for (int i = 0; i < DAP_EXC_FILTER_COUNT; i++) {
            cJSON *filter = cJSON_CreateObject();
            if (filter) {
                cJSON_AddStringToObject(filter, "filter", exception_filters[i].id);
                cJSON_AddStringToObject(filter, "label", exception_filters[i].label);
                cJSON_AddStringToObject(filter, "description", exception_filters[i].description);
                cJSON_AddBoolToObject(filter, "default", exception_filters[i].default_value);
                cJSON_AddItemToArray(exceptionFilters, filter);
            }
        }

        cJSON_AddItemToObject(capabilities, "exceptionBreakpointFilters", exceptionFilters);
    }

    // Set ANSI styling if client supports it
    if (server->client_capabilities.supportsANSIStyling) {
        cJSON_AddBoolToObject(capabilities, "supportsANSIStyling", true);
    }

    set_response_success(response, capabilities);
    // cJSON_Delete(capabilities); -- No longer needed, set_response_success will free it
    
    // Mark that we've received initialize
    server->is_initialized = true;
    
    // Note: The 'initialized' event will be sent by dap_server_handle_request
    // immediately after sending this response, as per the DAP specification
    
    return 0;
}

/**
 * @brief Handle execution control commands (continue, step, etc.)
 *
 * This function is currently unused but kept for future execution control implementation.
 * It will be used to centralize the handling of all execution control commands
 * and provide consistent behavior across different execution modes.
 */
int handle_execution_control(DAPServer *server, DAPCommandType command, cJSON *args, DAPResponse *response)
{
    if (!server->is_running || !server->attached)
    {
        set_response_error(response, "Debugger is not running or not attached");
        return -1;
    }

    // Parse thread ID and single_thread flag
    int thread_id = 1; // Default to thread 1
    bool single_thread = false;

    if (args)
    {
        cJSON *thread_id_json = cJSON_GetObjectItem(args, "threadId");
        if (thread_id_json && cJSON_IsNumber(thread_id_json))
        {
            thread_id = thread_id_json->valueint;
        }

        cJSON *single_thread_json = cJSON_GetObjectItem(args, "singleThread");
        if (single_thread_json && cJSON_IsBool(single_thread_json))
        {
            single_thread = cJSON_IsTrue(single_thread_json);
        }
    }

    // Validate thread ID
    if (thread_id != 1)
    {
        set_response_error(response, "Invalid thread ID - only thread 1 is supported");
        return -1;
    }

    // Handle different commands
    switch (command)
    {
    case DAP_CMD_PAUSE:
        if (!server->paused)
        {
            server->paused = true;
            // If single_thread is true, only pause the specified thread
            if (single_thread && thread_id != server->current_thread_id)
            {
                set_response_error(response, "Cannot pause non-current thread in single-thread mode");
                return -1;
            }

            // Create success response with thread information
            cJSON *body = cJSON_CreateObject();
            if (!body)
            {
                set_response_error(response, "Failed to create response body");
                return -1;
            }

            cJSON_AddNumberToObject(body, "threadId", thread_id);
            cJSON_AddStringToObject(body, "reason", "pause");
            cJSON_AddBoolToObject(body, "allThreadsStopped", true);

            set_response_success(response, body);
            // body is freed by set_response_success
            return 0;
        }
        set_response_error(response, "Debugger is already paused");
        return -1;

    case DAP_CMD_CONTINUE:
    case DAP_CMD_NEXT:
    case DAP_CMD_STEP_IN:
    case DAP_CMD_STEP_OUT:
        if (server->paused)
        {
            // If single_thread is true, only continue the specified thread
            if (single_thread && thread_id != server->current_thread_id)
            {
                set_response_error(response, "Cannot continue non-current thread in single-thread mode");
                return -1;
            }
            server->paused = false;
            set_response_success(response, NULL);
            return 0;
        }
        set_response_error(response, "Debugger is not paused");
        return -1;

    default:
        set_response_error(response, "Unsupported execution control command");
        return -1;
    }
}

int handle_set_breakpoints(DAPServer *server, cJSON *args, DAPResponse *response)
{
    if (!args || !response)
    {
        set_response_error(response, "Invalid arguments");
        return -1;
    }

    // Get source file path
    cJSON *source = cJSON_GetObjectItem(args, "source");
    if (!source)
    {
        set_response_error(response, "Missing source in arguments");
        return -1;
    }

    cJSON *path = cJSON_GetObjectItem(source, "path");
    if (!path || !cJSON_IsString(path))
    {
        set_response_error(response, "Invalid source path");
        return -1;
    }

    const char *source_path = path->valuestring;

    // Get breakpoints array
    cJSON *breakpoints = cJSON_GetObjectItem(args, "breakpoints");
    if (!breakpoints || !cJSON_IsArray(breakpoints))
    {
        set_response_error(response, "Invalid breakpoints array");
        return -1;
    }

    // Create response body
    cJSON *body = cJSON_CreateObject();
    if (!body)
    {
        set_response_error(response, "Failed to create response body");
        return -1;
    }

    cJSON *response_breakpoints = cJSON_CreateArray();
    if (!response_breakpoints)
    {
        cJSON_Delete(body);
        set_response_error(response, "Failed to create breakpoints array");
        return -1;
    }

    // First, clear all existing breakpoints for this source file
    for (int i = 0; i < server->breakpoint_count; i++)
    {
        if (server->breakpoints[i].source &&
            server->breakpoints[i].source->path &&
            strcmp(server->breakpoints[i].source->path, source_path) == 0)
        {

            // Free memory for the source
            free(server->breakpoints[i].source->path);
            free(server->breakpoints[i].source);
            server->breakpoints[i].source = NULL;

            // Mark for deletion (we'll handle actual deletion after the loop)
            server->breakpoints[i].id = 0;
        }
    }

    // Remove marked breakpoints
    int i = 0;
    while (i < server->breakpoint_count)
    {
        if (server->breakpoints[i].id == 0)
        {
            // Move last breakpoint to this position
            if (i < server->breakpoint_count - 1)
            {
                server->breakpoints[i] = server->breakpoints[server->breakpoint_count - 1];
            }
            server->breakpoint_count--;
        }
        else
        {
            i++;
        }
    }

    // Process each breakpoint
    int num_breakpoints = cJSON_GetArraySize(breakpoints);
    for (int i = 0; i < num_breakpoints; i++)
    {
        cJSON *bp = cJSON_GetArrayItem(breakpoints, i);
        if (!bp)
            continue;

        cJSON *line = cJSON_GetObjectItem(bp, "line");
        if (!line || !cJSON_IsNumber(line))
            continue;

        int line_num = line->valueint;
        if (line_num < 0)
            continue;

        cJSON *column = cJSON_GetObjectItem(bp, "column");
        int column_num = column && cJSON_IsNumber(column) ? column->valueint : 0;

        cJSON *condition = cJSON_GetObjectItem(bp, "condition");
        const char *condition_str = condition && cJSON_IsString(condition) ? condition->valuestring : NULL;

        cJSON *hit_condition = cJSON_GetObjectItem(bp, "hitCondition");
        const char *hit_condition_str = hit_condition && cJSON_IsString(hit_condition) ? hit_condition->valuestring : NULL;

        cJSON *log_message = cJSON_GetObjectItem(bp, "logMessage");
        const char *log_message_str = log_message && cJSON_IsString(log_message) ? log_message->valuestring : NULL;

        // Allocate a new breakpoint
        if (server->breakpoint_count >= MAX_BREAKPOINTS)
        {
            continue;
        }

        // Reallocate breakpoints array if needed
        DAPBreakpoint *new_breakpoints = realloc(server->breakpoints,
                                                 (server->breakpoint_count + 1) * sizeof(DAPBreakpoint));
        if (!new_breakpoints)
        {
            continue;
        }

        server->breakpoints = new_breakpoints;

        // Initialize new breakpoint
        int bp_idx = server->breakpoint_count;
        memset(&server->breakpoints[bp_idx], 0, sizeof(DAPBreakpoint));
        server->breakpoints[bp_idx].id = bp_idx + 1;
        server->breakpoints[bp_idx].line = line_num;
        server->breakpoints[bp_idx].column = column_num;
        server->breakpoints[bp_idx].verified = true;

        // Set source
        DAPSource *bp_source = malloc(sizeof(DAPSource));
        if (bp_source)
        {
            memset(bp_source, 0, sizeof(DAPSource));
            bp_source->path = strdup(source_path);

            // Extract filename from path
            const char *filename = strrchr(source_path, '/');
            if (filename)
            {
                bp_source->name = strdup(filename + 1);
            }
            else
            {
                bp_source->name = strdup(source_path);
            }

            server->breakpoints[bp_idx].source = bp_source;
        }

        // Set condition if provided
        if (condition_str)
        {
            server->breakpoints[bp_idx].condition = strdup(condition_str);
        }

        // Set hit condition if provided
        if (hit_condition_str)
        {
            server->breakpoints[bp_idx].hit_condition = strdup(hit_condition_str);
        }

        // Set log message if provided
        if (log_message_str)
        {
            server->breakpoints[bp_idx].log_message = strdup(log_message_str);
        }

        server->breakpoint_count++;

        // Create response breakpoint
        cJSON *response_bp = cJSON_CreateObject();
        if (!response_bp)
            continue;

        cJSON_AddNumberToObject(response_bp, "id", server->breakpoints[bp_idx].id);
        cJSON_AddBoolToObject(response_bp, "verified", true);
        cJSON_AddNumberToObject(response_bp, "line", line_num);

        if (column_num > 0)
        {
            cJSON_AddNumberToObject(response_bp, "column", column_num);
        }

        // Add source to response
        cJSON *source_obj = cJSON_CreateObject();
        if (source_obj)
        {
            cJSON_AddStringToObject(source_obj, "path", source_path);
            if (bp_source && bp_source->name)
            {
                cJSON_AddStringToObject(source_obj, "name", bp_source->name);
            }
            cJSON_AddItemToObject(response_bp, "source", source_obj);
        }

        cJSON_AddItemToArray(response_breakpoints, response_bp);
    }

    cJSON_AddItemToObject(body, "breakpoints", response_breakpoints);
    set_response_success(response, body);
    // body is freed by set_response_success
    return 0;
}

int handle_source(DAPServer *server, cJSON *args, DAPResponse *response)
{
    (void)server; // Mark as unused
    if (!args || !response)
    {
        set_response_error(response, "Invalid arguments");
        return -1;
    }

    cJSON *source = cJSON_GetObjectItem(args, "source");
    if (!source)
    {
        set_response_error(response, "No source specified");
        return -1;
    }

    cJSON *path = cJSON_GetObjectItem(source, "path");
    cJSON *sourceReference = cJSON_GetObjectItem(source, "sourceReference");

    // Check if we have a path or reference
    if ((!path || !cJSON_IsString(path)) &&
        (!sourceReference || !cJSON_IsNumber(sourceReference)))
    {
        set_response_error(response, "Invalid source path or reference");
        return -1;
    }

    // Create response body with source content
    cJSON *body = cJSON_CreateObject();
    if (!body)
    {
        set_response_error(response, "Failed to create response body");
        return -1;
    }

    // Try to read source file if a path is provided
    if (path && cJSON_IsString(path))
    {
        const char *file_path = path->valuestring;

        // Check if path is a directory
        struct stat path_stat;
        if (stat(file_path, &path_stat) == 0 && S_ISDIR(path_stat.st_mode))
        {
            cJSON_Delete(body);
            set_response_error(response, "Cannot read directory as source file");
            return -1;
        }

        FILE *f = fopen(file_path, "r");

        if (f)
        {
            // Get file size
            fseek(f, 0, SEEK_END);
            long file_size = ftell(f);
            fseek(f, 0, SEEK_SET);

            // Validate file size to avoid allocation issues
            if (file_size <= 0 || file_size > 10 * 1024 * 1024)
            { // Max 10MB for safety
                fclose(f);
                cJSON_Delete(body);
                set_response_error(response, "Invalid file size or file too large");
                return -1;
            }

            // Read file content
            char *content = malloc((size_t)file_size + 1);
            if (content)
            {
                size_t bytes_read = fread(content, 1, (size_t)file_size, f);
                content[bytes_read] = '\0'; // Null-terminate

                // Add content to response
                cJSON_AddStringToObject(body, "content", content);
                cJSON_AddStringToObject(body, "mimeType", "text/plain");

                free(content);
            }
            else
            {
                cJSON_Delete(body);
                fclose(f);
                set_response_error(response, "Failed to allocate memory for file content");
                return -1;
            }

            fclose(f);
        }
        else
        {
            // File could not be opened, return an error
            char error_msg[256];
            snprintf(error_msg, sizeof(error_msg), "Failed to open source file: %s", file_path);
            cJSON_Delete(body);
            set_response_error(response, error_msg);
            return -1;
        }
    }
    // Handle source reference (in-memory source)
    else if (sourceReference && cJSON_IsNumber(sourceReference))
    {
        int ref = sourceReference->valueint;

        // In a real implementation, this would look up source by reference ID
        // For the mock, we'll return a placeholder
        char source_content[256];
        snprintf(source_content, sizeof(source_content),
                 "// Generated source for reference %d\n"
                 "// This would be actual source code in a real implementation\n"
                 "int main() {\n"
                 "    return 0;\n"
                 "}\n",
                 ref);

        cJSON_AddStringToObject(body, "content", source_content);
        cJSON_AddStringToObject(body, "mimeType", "text/plain");
    }

    set_response_success(response, body);
    // body is freed by set_response_success
    return 0;
}

int handle_scopes(DAPServer *server, cJSON *args, DAPResponse *response)
{
    (void)server; // Mark as unused
    if (!args || !response)
    {
        set_response_error(response, "Invalid arguments");
        return -1;
    }

    cJSON *frameId = cJSON_GetObjectItem(args, "frameId");
    if (!frameId || !cJSON_IsNumber(frameId))
    {
        set_response_error(response, "Invalid frame ID");
        return -1;
    }

    // Create response body with scopes
    cJSON *body = cJSON_CreateObject();
    if (!body)
    {
        set_response_error(response, "Failed to create response body");
        return -1;
    }

    // Add scopes array
    cJSON *scopes = cJSON_CreateArray();
    if (!scopes)
    {
        cJSON_Delete(body);
        set_response_error(response, "Failed to create scopes array");
        return -1;
    }

    // Add CPU Registers scope (always available, even at entry point)
    cJSON *registersScope = cJSON_CreateObject();
    if (registersScope)
    {
        cJSON_AddStringToObject(registersScope, "name", "CPU Registers");
        cJSON_AddNumberToObject(registersScope, "variablesReference", 1);
        cJSON_AddNumberToObject(registersScope, "namedVariables", 8); // Number of CPU registers
        cJSON_AddBoolToObject(registersScope, "expensive", false);
        cJSON_AddStringToObject(registersScope, "presentationHint", "registers");
        cJSON_AddItemToArray(scopes, registersScope);
    }

    // Add CPU Flags scope (always available, even at entry point)
    cJSON *flagsScope = cJSON_CreateObject();
    if (flagsScope)
    {
        cJSON_AddStringToObject(flagsScope, "name", "CPU Flags");
        cJSON_AddNumberToObject(flagsScope, "variablesReference", 1001);
        cJSON_AddNumberToObject(flagsScope, "namedVariables", 4); // Number of CPU flags
        cJSON_AddBoolToObject(flagsScope, "expensive", false);
        cJSON_AddStringToObject(flagsScope, "presentationHint", "registers");
        cJSON_AddItemToArray(scopes, flagsScope);
    }

    // Add Internal Registers scope (always available, even at entry point)
    cJSON *internalScope = cJSON_CreateObject();
    if (internalScope)
    {
        cJSON_AddStringToObject(internalScope, "name", "Internal Registers");
        cJSON_AddNumberToObject(internalScope, "variablesReference", 4);
        cJSON_AddNumberToObject(internalScope, "namedVariables", 2); // Number of internal registers
        cJSON_AddBoolToObject(internalScope, "expensive", false);
        cJSON_AddStringToObject(internalScope, "presentationHint", "registers");
        cJSON_AddItemToArray(scopes, internalScope);
    }

    cJSON_AddItemToObject(body, "scopes", scopes);
    set_response_success(response, body);
    return 0;
}

int handle_variables(DAPServer *server, cJSON *args, DAPResponse *response)
{
    (void)server; // Mark as unused
    if (!args || !response)
    {
        set_response_error(response, "Invalid arguments");
        return -1;
    }

    cJSON *variablesReference = cJSON_GetObjectItem(args, "variablesReference");
    if (!variablesReference || !cJSON_IsNumber(variablesReference))
    {
        set_response_error(response, "Invalid variables reference");
        return -1;
    }

    // Create response body with variables
    cJSON *body = cJSON_CreateObject();
    if (!body)
    {
        set_response_error(response, "Failed to create response body");
        return -1;
    }

    // Add variables array
    cJSON *variables = cJSON_CreateArray();
    if (!variables)
    {
        cJSON_Delete(body);
        set_response_error(response, "Failed to create variables array");
        return -1;
    }

    int ref = variablesReference->valueint;
    Register *reg_array = NULL;
    size_t reg_count = 0;
    cJSON *readScope = NULL;
    cJSON *writeScope = NULL;

    // Select appropriate register array based on reference
    switch (ref)
    {
    case 1: // CPU Registers
        reg_array = cpu_registers;
        reg_count = NUM_REGISTERS;
        break;
    case 2: // Internal Read Registers
        reg_array = internal_read_registers;
        reg_count = NUM_INTERNAL_READ_REGISTERS;
        break;
    case 3: // Internal Write Registers
        reg_array = internal_write_registers;
        reg_count = NUM_INTERNAL_WRITE_REGISTERS;
        break;
    case 4: // Internal Registers parent scope
        // Add subscopes for internal registers with detailed information
        readScope = cJSON_CreateObject();
        if (readScope)
        {
            cJSON_AddStringToObject(readScope, "name", "Read Registers");
            cJSON_AddStringToObject(readScope, "value", "Read-only internal registers");
            cJSON_AddStringToObject(readScope, "type", "scope");
            cJSON_AddNumberToObject(readScope, "variablesReference", 2);
            cJSON_AddNumberToObject(readScope, "namedVariables", NUM_INTERNAL_READ_REGISTERS);
            cJSON_AddBoolToObject(readScope, "expensive", false);
            cJSON_AddStringToObject(readScope, "presentationHint", "registers");
            cJSON_AddItemToArray(variables, readScope);
        }
        writeScope = cJSON_CreateObject();
        if (writeScope)
        {
            cJSON_AddStringToObject(writeScope, "name", "Write Registers");
            cJSON_AddStringToObject(writeScope, "value", "Write-only internal registers");
            cJSON_AddStringToObject(writeScope, "type", "scope");
            cJSON_AddNumberToObject(writeScope, "variablesReference", 3);
            cJSON_AddNumberToObject(writeScope, "namedVariables", NUM_INTERNAL_WRITE_REGISTERS);
            cJSON_AddBoolToObject(writeScope, "expensive", false);
            cJSON_AddStringToObject(writeScope, "presentationHint", "registers");
            cJSON_AddItemToArray(variables, writeScope);
        }
        break;
    case 1001: // Status Register Flags
        // Add status flags as variables
        for (size_t i = 0; i < NUM_STATUS_FLAGS; i++)
        {
            cJSON *var = cJSON_CreateObject();
            if (var)
            {
                cJSON_AddStringToObject(var, "name", status_flags[i].name);
                cJSON_AddStringToObject(var, "value", status_flags[i].value ? "1" : "0");
                cJSON_AddStringToObject(var, "type", status_flags[i].type);
                cJSON_AddNumberToObject(var, "variablesReference", 0);
                
                // Create proper presentationHint object instead of string
                cJSON *presentation_hint = cJSON_CreateObject();
                if (presentation_hint) {
                    // Add kind (property for registers)
                    cJSON_AddStringToObject(presentation_hint, "kind", "property");
                    
                    // Add attributes array
                    cJSON *attributes = cJSON_CreateArray();
                    if (attributes) {
                        // Registers are typically read-only in UI
                        cJSON_AddItemToArray(attributes, cJSON_CreateString("readOnly"));
                        
                        // Add static attribute for registers
                        cJSON_AddItemToArray(attributes, cJSON_CreateString("static"));
                        
                        cJSON_AddItemToObject(presentation_hint, "attributes", attributes);
                    }
                    
                    // Add visibility (public for registers)
                    cJSON_AddStringToObject(presentation_hint, "visibility", "public");
                    
                    // Add presentationHint object to variable
                    cJSON_AddItemToObject(var, "presentationHint", presentation_hint);
                }
                
                cJSON_AddItemToArray(variables, var);
            }
        }
        break;
    default:
    {
        // Create error response
        response->success = false;

        // Create error object with more user-friendly message
        cJSON *error = cJSON_CreateObject();
        if (error)
        {
            cJSON_AddNumberToObject(error, "id", 1000);
            cJSON_AddStringToObject(error, "format", "Invalid variables reference %d - no such variable group exists");
            cJSON_AddNumberToObject(error, "variablesReference", ref);
            cJSON_AddBoolToObject(error, "showUser", true);

            // Create response body with error
            cJSON *body = cJSON_CreateObject();
            if (body)
            {
                cJSON_AddItemToObject(body, "error", error);
                char *body_str = cJSON_PrintUnformatted(body);
                if (body_str)
                {
                    response->data = body_str;
                    response->data_size = strlen(body_str);
                    cJSON_Delete(body);
                    return 0;
                }
                cJSON_Delete(body);
            }
            cJSON_Delete(error);
        }
        set_response_error(response, "Failed to create error response");
        return -1;
    }
    }

    // Add registers as variables if not handling status flags or internal parent scope
    if (ref != 1001 && ref != 4 && reg_array)
    {
        for (size_t i = 0; i < reg_count; i++)
        {
            cJSON *var = cJSON_CreateObject();
            if (var)
            {
                cJSON_AddStringToObject(var, "name", reg_array[i].name);
                char value_str[32];
                if (strcmp(reg_array[i].type, "octal") == 0)
                {
                    snprintf(value_str, sizeof(value_str), "%o", reg_array[i].value);
                }
                else
                {
                    snprintf(value_str, sizeof(value_str), "0x%04x", reg_array[i].value);
                }
                cJSON_AddStringToObject(var, "value", value_str);
                cJSON_AddStringToObject(var, "type", reg_array[i].type);
                cJSON_AddNumberToObject(var, "variablesReference", reg_array[i].nested_ref);
                
                // Create proper presentationHint object instead of string
                cJSON *presentation_hint = cJSON_CreateObject();
                if (presentation_hint) {
                    // Add kind (property for registers)
                    cJSON_AddStringToObject(presentation_hint, "kind", "property");
                    
                    // Add attributes array
                    cJSON *attributes = cJSON_CreateArray();
                    if (attributes) {
                        // Registers are typically read-only in UI
                        cJSON_AddItemToArray(attributes, cJSON_CreateString("readOnly"));
                        
                        // Add static attribute for registers
                        cJSON_AddItemToArray(attributes, cJSON_CreateString("static"));
                        
                        cJSON_AddItemToObject(presentation_hint, "attributes", attributes);
                    }
                    
                    // Add visibility (public for registers)
                    cJSON_AddStringToObject(presentation_hint, "visibility", "public");
                    
                    // Add presentationHint object to variable
                    cJSON_AddItemToObject(var, "presentationHint", presentation_hint);
                }
                
                cJSON_AddItemToArray(variables, var);
            }
        }
    }

    cJSON_AddItemToObject(body, "variables", variables);
    set_response_success(response, body);
    // body is freed by set_response_success
    return 0;
}

/*
 * Thread ID Implementation Notes:
 *
 * The mock debugger implements a simplified thread model where:
 * - Thread ID 1 is the only valid thread ID
 * - This represents the main CPU thread in the ND-100 architecture
 * - The mock debugger does not support multiple threads as the ND-100 is a single-threaded CPU
 * - Thread ID 0 is not used to represent "all threads" as per DAP specification
 * - Instead, the 'singleThread' flag is used to control thread-specific operations
 *
 * This implementation aligns with the ND-100 architecture while maintaining DAP compliance:
 * - All thread operations default to thread ID 1
 * - Thread-specific operations require thread ID 1
 * - The 'singleThread' flag is properly handled for thread control
 */

int handle_threads(DAPServer *server, cJSON *args, DAPResponse *response)
{

    (void)args; // Mark as unused

    // Create response body
    cJSON *body = cJSON_CreateObject();
    if (!body)
    {
        response->success = false;
        response->error_message = strdup("Failed to create response body");
        return 0;
    }

    // Create threads array
    cJSON *threads = cJSON_CreateArray();
    if (!threads)
    {
        cJSON_Delete(body);
        response->success = false;
        response->error_message = strdup("Failed to create threads array");
        return 0;
    }

    // Create thread object
    cJSON *thread = cJSON_CreateObject();
    if (!thread)
    {
        cJSON_Delete(body);
        cJSON_Delete(threads);
        response->success = false;
        response->error_message = strdup("Failed to create thread object");
        return 0;
    }

    // Add thread properties
    cJSON_AddNumberToObject(thread, "id", 1); // Always use thread ID 1
    cJSON_AddStringToObject(thread, "name", "CPU thread");

    // Add thread state based on debugger state
    if (!server->is_running || !server->attached)
    {
        cJSON_AddStringToObject(thread, "state", "stopped");
    }
    else if (server->paused)
    {
        cJSON_AddStringToObject(thread, "state", "paused");
    }
    else
    {
        cJSON_AddStringToObject(thread, "state", "running");
    }

    // Add thread to array
    cJSON_AddItemToArray(threads, thread);

    // Add threads array to body
    cJSON_AddItemToObject(body, "threads", threads);

    // Convert to string
    char *body_str = cJSON_PrintUnformatted(body);
    cJSON_Delete(body);
    if (!body_str)
    {
        response->success = false;
        response->error_message = strdup("Failed to format response body");
        return 0;
    }

    response->success = true;
    response->data = body_str;
    return 0;
}

/*
 * Stack Trace Implementation Notes:
 *
 * The mock debugger implements a simplified stack trace model where:
 * - Only one stack frame is maintained (the current execution frame)
 * - The frame represents the current program counter (PC) position
 * - Source line information is included when available through line mappings
 * - The stack frame includes:
 *   - Frame ID (always 0 for the single frame)
 *   - Function name (always "main" for the single frame)
 *   - Current line and column from source mapping
 *   - Source file information when available
 *
 * This implementation reflects the ND-100's simple execution model:
 * - No call stack (no function calls in the traditional sense)
 * - Direct program counter-based execution
 * - Source line mapping for debugging information
 * - Single execution context
 */

int handle_stack_trace(DAPServer *server, cJSON *args, DAPResponse *response)
{
    if (!server->is_running || !server->attached)
    {
        set_response_error(response, "Debugger is not running or not attached");
        return -1;
    }

    // Create response body
    cJSON *body = cJSON_CreateObject();
    if (!body)
    {
        set_response_error(response, "Failed to create response body");
        return -1;
    }

    // Parse arguments
    int thread_id = 1; // Default to thread 1
    int start_frame = 0;
    int levels = 1;
    cJSON *format = NULL;

    if (args)
    {
        cJSON *thread_id_json = cJSON_GetObjectItem(args, "threadId");
        if (thread_id_json && cJSON_IsNumber(thread_id_json))
        {
            thread_id = thread_id_json->valueint;
        }

        cJSON *start_frame_json = cJSON_GetObjectItem(args, "startFrame");
        if (start_frame_json && cJSON_IsNumber(start_frame_json))
        {
            start_frame = start_frame_json->valueint;
        }

        cJSON *levels_json = cJSON_GetObjectItem(args, "levels");
        if (levels_json && cJSON_IsNumber(levels_json))
        {
            levels = levels_json->valueint;
        }

        format = cJSON_GetObjectItem(args, "format");
    }

    // Validate thread ID
    if (thread_id != 1)
    {
        cJSON_Delete(body);
        set_response_error(response, "Invalid thread ID - only thread 1 is supported");
        return -1;
    }

    // Validate start_frame and levels
    if (start_frame < 0 || levels < 1)
    {
        cJSON_Delete(body);
        set_response_error(response, "Invalid start_frame or levels parameter");
        return -1;
    }

    // Create stack frames array
    cJSON *frames = cJSON_CreateArray();
    if (!frames)
    {
        cJSON_Delete(body);
        set_response_error(response, "Failed to create frames array");
        return -1;
    }

    // Create current frame
    cJSON *frame = cJSON_CreateObject();
    if (!frame)
    {
        cJSON_Delete(body);
        cJSON_Delete(frames);
        set_response_error(response, "Failed to create frame object");
        return -1;
    }

    // Add frame properties
    cJSON_AddNumberToObject(frame, "id", start_frame);
    cJSON_AddStringToObject(frame, "name", "main");
    cJSON_AddNumberToObject(frame, "line", server->current_line);
    cJSON_AddNumberToObject(frame, "column", server->current_column);

    // Add source information if available
    if (server->current_source && server->current_source->path)
    {
        cJSON *source = cJSON_CreateObject();
        if (source)
        {
            cJSON_AddStringToObject(source, "path", server->current_source->path);
            if (server->current_source->name)
            {
                cJSON_AddStringToObject(source, "name", server->current_source->name);
            }
            cJSON_AddItemToObject(frame, "source", source);
        }
    }

    // Add presentation hint if format is specified
    if (format)
    {
        cJSON *presentation_hint = cJSON_CreateObject();
        if (presentation_hint)
        {
            cJSON *parameters = cJSON_GetObjectItem(format, "parameters");
            if (parameters)
            {
                cJSON *show_hidden = cJSON_GetObjectItem(parameters, "showHidden");
                if (show_hidden && cJSON_IsBool(show_hidden))
                {
                    cJSON_AddBoolToObject(presentation_hint, "showHidden", cJSON_IsTrue(show_hidden));
                }
            }
            cJSON_AddItemToObject(frame, "presentationHint", presentation_hint);
        }
    }

    // Add frame to array
    cJSON_AddItemToArray(frames, frame);

    // Add frames array to body
    cJSON_AddItemToObject(body, "stackFrames", frames);

    // Add total frames count (limited by levels parameter)
    cJSON_AddNumberToObject(body, "totalFrames", levels > 1 ? levels : 1);

    // Set response
    set_response_success(response, body);
    // No need to delete body as set_response_success now takes ownership and frees it
    return 0;
}

/**
 * @brief Handle disassemble command
 *
 * @param args Command arguments
 * @param response Response structure to fill
 * @return int 0 on success, non-zero on failure
 */
int handle_disassemble(DAPServer *server, cJSON *args, DAPResponse *response)
{
    (void)server; // Mark as unused
    if (!args || !response)
    {
        set_response_error(response, "Invalid arguments");
        return -1;
    }

    // Parse required arguments
    cJSON *memory_reference = cJSON_GetObjectItem(args, "memoryReference");
    if (!memory_reference || !cJSON_IsString(memory_reference))
    {
        set_response_error(response, "Missing or invalid memoryReference");
        return -1;
    }

    // Parse optional arguments with defaults
    uint64_t offset = 0;
    cJSON *offset_json = cJSON_GetObjectItem(args, "offset");
    if (offset_json && cJSON_IsNumber(offset_json))
    {
        offset = (uint64_t)offset_json->valuedouble;
    }

    int instruction_offset = 0;
    cJSON *instruction_offset_json = cJSON_GetObjectItem(args, "instructionOffset");
    if (instruction_offset_json && cJSON_IsNumber(instruction_offset_json))
    {
        instruction_offset = (size_t)instruction_offset_json->valueint;
    }

    size_t instruction_count = 10; // Default to 10 instructions
    cJSON *instruction_count_json = cJSON_GetObjectItem(args, "instructionCount");
    if (instruction_count_json && cJSON_IsNumber(instruction_count_json))
    {
        instruction_count = (size_t)instruction_count_json->valueint;
    }

    bool resolve_symbols = false;
    cJSON *resolve_symbols_json = cJSON_GetObjectItem(args, "resolveSymbols");
    if (resolve_symbols_json && cJSON_IsBool(resolve_symbols_json))
    {
        resolve_symbols = cJSON_IsTrue(resolve_symbols_json);
    }

    // Convert memory reference to address
    char *endptr = NULL;
    uint32_t address = (uint32_t)strtoul(memory_reference->valuestring, &endptr, 0);
    if (endptr == memory_reference->valuestring || *endptr != '\0')
    {
        set_response_error(response, "Invalid memory reference format");
        return -1;
    }

    // Apply offset to address
    address += (uint32_t)offset;

    // Create response body
    cJSON *body = cJSON_CreateObject();
    if (!body)
    {
        set_response_error(response, "Failed to create response body");
        return -1;
    }

    cJSON *instructions = cJSON_CreateArray();
    if (!instructions)
    {
        cJSON_Delete(body);
        set_response_error(response, "Failed to create instructions array");
        return -1;
    }

    // Calculate total instructions to disassemble
    size_t total_instructions = instruction_count + instruction_offset;
    if (instruction_offset < 0)
    {
        total_instructions = instruction_count;
    }

    // Allocate array for disassembly strings
    char **disassembly = malloc(total_instructions * sizeof(char *));
    if (!disassembly)
    {
        cJSON_Delete(body);
        cJSON_Delete(instructions);
        set_response_error(response, "Failed to allocate memory for disassembly");
        return -1;
    }

    // Mock disassembly - in a real implementation, this would use the machine debugger
    for (size_t i = 0; i < total_instructions; i++)
    {
        char *instr = malloc(32);
        if (!instr)
        {
            // Clean up previously allocated strings
            for (size_t j = 0; j < i; j++)
            {
                free(disassembly[j]);
            }
            free(disassembly);
            cJSON_Delete(body);
            cJSON_Delete(instructions);
            set_response_error(response, "Failed to allocate memory for instruction");
            return -1;
        }
        snprintf(instr, 32, "MOV R%d, R%d", (int)(i % 8), (int)((i + 1) % 8));
        disassembly[i] = instr;
    }

    // Add instructions to response
    for (size_t i = 0; i < instruction_count; i++)
    {
        size_t idx = i + instruction_offset;
        if (idx >= total_instructions || !disassembly[idx])
        {
            break;
        }

        cJSON *instruction = cJSON_CreateObject();
        if (!instruction)
        {
            // Clean up and return error
            for (size_t j = 0; j < total_instructions; j++)
            {
                free(disassembly[j]);
            }
            free(disassembly);
            cJSON_Delete(body);
            cJSON_Delete(instructions);
            set_response_error(response, "Failed to create instruction object");
            return -1;
        }

        // Format address as hexadecimal
        char addr_str[16];
        snprintf(addr_str, sizeof(addr_str), "0x%04x", address + (uint32_t)(i * 4));
        cJSON_AddStringToObject(instruction, "address", addr_str);

        // Add instruction text
        cJSON_AddStringToObject(instruction, "instruction", disassembly[idx]);

        // If resolve_symbols is true, try to resolve symbol names
        if (resolve_symbols)
        {
            // Mock symbol resolution
            cJSON_AddStringToObject(instruction, "symbol", "");
        }

        cJSON_AddItemToArray(instructions, instruction);
    }

    // Clean up disassembly strings
    for (size_t i = 0; i < total_instructions; i++)
    {
        free(disassembly[i]);
    }
    free(disassembly);

    // Add instructions array to body
    cJSON_AddItemToObject(body, "instructions", instructions);

    // Set response
    response->success = true;
    response->error_message = NULL;
    response->data = cJSON_PrintUnformatted(body);
    response->data_size = response->data ? strlen(response->data) : 0;

    // Clean up
    cJSON_Delete(body);

    return 0;
}

int handle_continue(DAPServer *server, cJSON *args, DAPResponse *response)
{
    (void)args; // Mark as unused
    if (!server->is_running || !server->attached)
    {
        set_response_error(response, "Debugger not running or attached");
        return -1;
    }

    if (!server->paused)
    {
        set_response_error(response, "Debugger not paused");
        return -1;
    }

    // Create success response
    cJSON *body = cJSON_CreateObject();
    if (!body)
    {
        set_response_error(response, "Failed to create response body");
        return -1;
    }

    cJSON_AddBoolToObject(body, "allThreadsContinued", true);

    set_response_success(response, body);
    // body is freed by set_response_success

    server->paused = false;
    return 0;
}

int handle_next(DAPServer *server, cJSON *args, DAPResponse *response)
{
    (void)args; // Mark as unused
    if (!server->is_running || !server->attached)
    {
        response->success = false;
        response->error_message = strdup("Debugger not running or attached");
        return 0;
    }

    if (!server->paused)
    {
        response->success = false;
        response->error_message = strdup("Debugger not paused");
        return 0;
    }

    // Create response body
    cJSON *body = cJSON_CreateObject();
    if (!body)
    {
        response->success = false;
        response->error_message = strdup("Failed to create response body");
        return 0;
    }

    cJSON_AddStringToObject(body, "reason", "step");
    cJSON_AddNumberToObject(body, "threadId", server->current_thread_id);
    cJSON_AddBoolToObject(body, "allThreadsStopped", true);
    cJSON_AddStringToObject(body, "description", "Stepped over instruction");

    // Convert to string
    char *body_str = cJSON_PrintUnformatted(body);
    cJSON_Delete(body);
    if (!body_str)
    {
        response->success = false;
        response->error_message = strdup("Failed to format response body");
        return 0;
    }

    // Simulate stepping over

    if (server->step_cpu)
    {
        int new_pc = server->step_cpu(server);
        if (new_pc != -1)
        {
            server->current_pc = new_pc;
            int line = get_line_for_address(server, new_pc);
            if (line > 0)
            {
                server->current_line = line;
            }

            response->success = true;
            response->data = body_str;
        }
    }
    else
    {
        response->success = false;
        response->error_message = strdup("Failed to step cpu");
        return 0;
    }

    // Send event
    cJSON *event_body = cJSON_CreateObject();
    if (event_body)
    {

        if (server->current_source)
        {
            cJSON *source = cJSON_CreateObject();
            if (source)
            {
                cJSON_AddStringToObject(source, "name", server->current_source->name);
                cJSON_AddStringToObject(source, "path", server->current_source->path);
                cJSON_AddItemToObject(event_body, "source", source);
            }
        }

        // Add line information if available
        if (server->current_line > 0)
        {
            cJSON_AddNumberToObject(event_body, "line", server->current_line);
            cJSON_AddNumberToObject(event_body, "column", server->current_column);
        }

        // Use dap_server_send_event instead of manual event creation and sending
        dap_server_send_event(server, "stopped", event_body);
        // Remove this line as it causes a double-free - dap_server_send_event already handles freeing the body
        // cJSON_Delete(event_body);
    }

    return 0;
}

int handle_step_in(DAPServer *server, cJSON *args, DAPResponse *response)
{
    if (!server->is_running || !server->attached)
    {
        response->success = false;
        response->error_message = strdup("Debugger not running or attached");
        return 0;
    }

    if (!server->paused)
    {
        response->success = false;
        response->error_message = strdup("Debugger not paused");
        return 0;
    }

    // Parse arguments
    int thread_id = -1;
    bool single_thread = false;

    const char *granularity = NULL;

    cJSON *thread_id_json = cJSON_GetObjectItem(args, "threadId");
    if (thread_id_json && cJSON_IsNumber(thread_id_json))
    {
        thread_id = thread_id_json->valueint;
    }

    cJSON *single_thread_json = cJSON_GetObjectItem(args, "singleThread");
    if (single_thread_json && cJSON_IsBool(single_thread_json))
    {
        single_thread = cJSON_IsTrue(single_thread_json);
    }

    /*  // This part is commented out as it is not used in the current implementation
        int target_id = -1;
        cJSON* target_id_json = cJSON_GetObjectItem(args, "targetId");
        if (target_id_json && cJSON_IsNumber(target_id_json)) {
            target_id = target_id_json->valueint;
        }
    */

    cJSON *granularity_json = cJSON_GetObjectItem(args, "granularity");
    if (granularity_json && cJSON_IsString(granularity_json))
    {
        granularity = granularity_json->valuestring;
    }

    // Validate thread ID
    if (thread_id < 0)
    {
        response->success = false;
        response->error_message = strdup("Invalid thread ID");
        return 0;
    }

    // Create response body
    cJSON *body = cJSON_CreateObject();
    if (!body)
    {
        response->success = false;
        response->error_message = strdup("Failed to create response body");
        return 0;
    }

    cJSON_AddBoolToObject(body, "allThreadsStopped", !single_thread);

    // Convert to string
    char *body_str = cJSON_PrintUnformatted(body);
    cJSON_Delete(body);
    if (!body_str)
    {
        response->success = false;
        response->error_message = strdup("Failed to format response body");
        return 0;
    }

    // Simulate stepping in based on granularity
    int (*handler)(DAPServer *) = NULL;
    int line = 0;

    if (granularity && strcmp(granularity, "instruction") == 0)
    {
        handler = server->step_cpu;
    }
    else if (granularity && strcmp(granularity, "line") == 0)
    {
        handler = server->step_cpu_line;
    }
    else
    {
        // Default to statement/line granularity
        handler = server->step_cpu_statement;
    }

    // Execute the appropriate step function
    if (handler)
    {
        int new_pc = handler(server);
        if (new_pc != -1)
        {
            server->current_pc = new_pc;
            line = get_line_for_address(server, new_pc);
            if (line > 0)
            {
                server->current_line = line;
            }
        }
        response->success = true;
        response->data = body_str;
    }
    else
    {
        response->success = false;
        response->error_message = strdup("Failed to step cpu");
        return 0;
    }

    cJSON *event_body = cJSON_CreateObject();
    if (event_body)
    {
        cJSON_AddStringToObject(event_body, "reason", "step");
        cJSON_AddNumberToObject(event_body, "threadId", thread_id);
        cJSON_AddBoolToObject(event_body, "allThreadsStopped", !single_thread);
        cJSON_AddStringToObject(event_body, "description", "Stepped into instruction");

        if (server->current_source)
        {
            cJSON *source = cJSON_CreateObject();
            if (source)
            {
                cJSON_AddStringToObject(source, "name", server->current_source->name);
                cJSON_AddStringToObject(source, "path", server->current_source->path);
                cJSON_AddItemToObject(event_body, "source", source);
            }
        }

        // Add line information if available
        if (line > 0)
        {
            cJSON_AddNumberToObject(event_body, "line", line);
            cJSON_AddNumberToObject(event_body, "column", server->current_column);
        }

        dap_server_send_event(server, "stopped", event_body);
        // Remove this line as it causes a double-free - dap_server_send_event already handles freeing the body
        // cJSON_Delete(event_body);
    }

    return 0;
}

int handle_step_out(DAPServer *server, cJSON *args, DAPResponse *response)
{
    (void)args; // Mark as unused
    if (!server->is_running || !server->attached)
    {
        response->success = false;
        response->error_message = strdup("Debugger not running or attached");
        return 0;
    }

    if (!server->paused)
    {
        response->success = false;
        response->error_message = strdup("Debugger not paused");
        return 0;
    }

    // Create response body
    cJSON *body = cJSON_CreateObject();
    if (!body)
    {
        response->success = false;
        response->error_message = strdup("Failed to create response body");
        return 0;
    }

    cJSON_AddBoolToObject(body, "allThreadsStopped", true);

    // Convert to string
    char *body_str = cJSON_PrintUnformatted(body);
    cJSON_Delete(body);
    if (!body_str)
    {
        response->success = false;
        response->error_message = strdup("Failed to format response body");
        return 0;
    }

    // Simulate stepping out
    int line = 0;
    if (server->step_cpu)
    {
        // Call step_cpu multiple times to simulate stepping out
        for (int i = 0; i < 4; i++)
        {
            server->step_cpu(server);
        }

        // Get line information for current PC
        line = get_line_for_address(server, server->current_pc);
        if (line > 0)
        {
            server->current_line = line;
        }
    }

    response->success = true;
    response->data = body_str;

    // Send event
    cJSON *event_body = cJSON_CreateObject();
    if (event_body)
    {
        cJSON_AddStringToObject(event_body, "reason", "step");
        cJSON_AddNumberToObject(event_body, "threadId", server->current_thread_id);
        cJSON_AddBoolToObject(event_body, "allThreadsStopped", true);
        cJSON_AddStringToObject(event_body, "description", "Stepped out of function");

        if (server->current_source)
        {
            cJSON *source = cJSON_CreateObject();
            if (source)
            {
                cJSON_AddStringToObject(source, "name", server->current_source->name);
                cJSON_AddStringToObject(source, "path", server->current_source->path);
                cJSON_AddItemToObject(event_body, "source", source);
            }
        }

        // Add line information if available
        if (line > 0)
        {
            cJSON_AddNumberToObject(event_body, "line", line);
            cJSON_AddNumberToObject(event_body, "column", server->current_column);
        }

        dap_server_send_event(server, "stopped", event_body);
        // Remove this line as it causes a double-free - dap_server_send_event already handles freeing the body
        // cJSON_Delete(event_body);
    }

    return 0;
}

int handle_read_memory(DAPServer *server, cJSON *args, DAPResponse *response)
{
    (void)args; // Mark as unused
    if (!server->is_running || !server->attached)
    {
        response->success = false;
        response->error_message = strdup("Debugger not running or attached");
        return 0;
    }

    // Get memory read parameters
    cJSON *address_json = cJSON_GetObjectItem(args, "address");
    cJSON *count_json = cJSON_GetObjectItem(args, "count");
    if (!address_json || !count_json)
    {
        response->success = false;
        response->error_message = strdup("Missing required parameters");
        return 0;
    }

    uint64_t address = address_json->valueint;
    int count = count_json->valueint;

    // Validate parameters
    if (count <= 0 || count > 1024)
    {
        response->success = false;
        response->error_message = strdup("Invalid count parameter");
        return 0;
    }

    // Create response body
    cJSON *body = cJSON_CreateObject();
    if (!body)
    {
        response->success = false;
        response->error_message = strdup("Failed to create response body");
        return 0;
    }

    // Simulate memory read
    char *data = (char *)malloc(count);
    if (!data)
    {
        cJSON_Delete(body);
        response->success = false;
        response->error_message = strdup("Failed to allocate memory");
        return 0;
    }

    // Fill with mock data
    for (int i = 0; i < count; i++)
    {
        data[i] = (char)((address + i) & 0xFF);
    }

    // Add to response
    char address_str[32];
    snprintf(address_str, sizeof(address_str), "0x%lx", address);
    cJSON_AddStringToObject(body, "address", address_str);
    cJSON_AddNumberToObject(body, "unreadableBytes", 0);
    cJSON_AddStringToObject(body, "data", data);
    free(data);

    // Convert to string
    char *body_str = cJSON_PrintUnformatted(body);
    cJSON_Delete(body);
    if (!body_str)
    {
        response->success = false;
        response->error_message = strdup("Failed to format response body");
        return 0;
    }

    response->success = true;
    response->data = body_str;
    return 0;
}

int handle_write_memory(DAPServer *server, cJSON *args, DAPResponse *response)
{
    (void)args; // Mark as unused
    if (!server->is_running || !server->attached)
    {
        response->success = false;
        response->error_message = strdup("Debugger not running or attached");
        return 0;
    }

    // Get memory write parameters
    cJSON *address_json = cJSON_GetObjectItem(args, "address");
    cJSON *data_json = cJSON_GetObjectItem(args, "data");
    if (!address_json || !data_json)
    {
        response->success = false;
        response->error_message = strdup("Missing required parameters");
        return 0;
    }

    // Create response body
    cJSON *body = cJSON_CreateObject();
    if (!body)
    {
        response->success = false;
        response->error_message = strdup("Failed to create response body");
        return 0;
    }

    // Simulate memory write
    cJSON_AddNumberToObject(body, "bytesWritten", strlen(data_json->valuestring));

    // Convert to string
    char *body_str = cJSON_PrintUnformatted(body);
    cJSON_Delete(body);
    if (!body_str)
    {
        response->success = false;
        response->error_message = strdup("Failed to format response body");
        return 0;
    }

    response->success = true;
    response->data = body_str;
    return 0;
}

int handle_read_registers(DAPServer *server, cJSON *args, DAPResponse *response)
{
    (void)args; // Mark as unused
    if (!server->is_running || !server->attached)
    {
        response->success = false;
        response->error_message = strdup("Debugger not running or attached");
        return 0;
    }

    // Create response body
    cJSON *body = cJSON_CreateObject();
    if (!body)
    {
        response->success = false;
        response->error_message = strdup("Failed to create response body");
        return 0;
    }

    // Create registers array
    cJSON *registers = cJSON_CreateArray();
    if (!registers)
    {
        cJSON_Delete(body);
        response->success = false;
        response->error_message = strdup("Failed to create registers array");
        return 0;
    }

    // Add CPU registers
    for (size_t i = 0; i < NUM_REGISTERS; i++)
    {
        cJSON *reg = cJSON_CreateObject();
        if (!reg)
        {
            cJSON_Delete(registers);
            cJSON_Delete(body);
            response->success = false;
            response->error_message = strdup("Failed to create register object");
            return 0;
        }

        cJSON_AddStringToObject(reg, "name", cpu_registers[i].name);
        char value_str[32];
        snprintf(value_str, sizeof(value_str), "0x%04x", cpu_registers[i].value);
        cJSON_AddStringToObject(reg, "value", value_str);
        cJSON_AddStringToObject(reg, "type", cpu_registers[i].type);
        if (cpu_registers[i].has_nested)
        {
            cJSON_AddNumberToObject(reg, "variablesReference", cpu_registers[i].nested_ref);
        }
        cJSON_AddItemToArray(registers, reg);
    }

    cJSON_AddItemToObject(body, "registers", registers);

    // Convert to string
    char *body_str = cJSON_PrintUnformatted(body);
    cJSON_Delete(body);
    if (!body_str)
    {
        response->success = false;
        response->error_message = strdup("Failed to format response body");
        return 0;
    }

    response->success = true;
    response->data = body_str;
    return 0;
}

int handle_write_register(DAPServer *server, cJSON *args, DAPResponse *response)
{
    (void)args; // Mark as unused
    if (!server->is_running || !server->attached)
    {
        response->success = false;
        response->error_message = strdup("Debugger not running or attached");
        return 0;
    }

    // Get register write parameters
    cJSON *name_json = cJSON_GetObjectItem(args, "name");
    cJSON *value_json = cJSON_GetObjectItem(args, "value");
    if (!name_json || !value_json)
    {
        response->success = false;
        response->error_message = strdup("Missing required parameters");
        return 0;
    }

    const char *name = name_json->valuestring;
    const char *value = value_json->valuestring;

    // Find register in CPU registers
    int reg_index = -1;
    for (size_t i = 0; i < NUM_REGISTERS; i++)
    {
        if (strcmp(name, cpu_registers[i].name) == 0)
        {
            reg_index = i;
            break;
        }
    }

    if (reg_index == -1)
    {
        response->success = false;
        response->error_message = strdup("Invalid register name");
        return 0;
    }

    // Parse value based on register type
    uint16_t reg_value;
    if (strcmp(cpu_registers[reg_index].type, "octal") == 0)
    {
        if (sscanf(value, "%ho", &reg_value) != 1)
        {
            response->success = false;
            response->error_message = strdup("Invalid octal value");
            return 0;
        }
    }
    else
    {
        if (sscanf(value, "0x%hx", &reg_value) != 1)
        {
            response->success = false;
            response->error_message = strdup("Invalid hex value");
            return 0;
        }
    }

    // Update register
    cpu_registers[reg_index].value = reg_value;

    // Create response body
    cJSON *body = cJSON_CreateObject();
    if (!body)
    {
        response->success = false;
        response->error_message = strdup("Failed to create response body");
        return 0;
    }

    // Convert to string
    char *body_str = cJSON_PrintUnformatted(body);
    cJSON_Delete(body);
    if (!body_str)
    {
        response->success = false;
        response->error_message = strdup("Failed to format response body");
        return 0;
    }

    response->success = true;
    response->data = body_str;
    return 0;
}

int handle_pause(DAPServer *server, cJSON *args, DAPResponse *response)
{
    if (!server->is_running || !server->attached)
    {
        response->success = false;
        response->error_message = strdup("Debugger not running or attached");
        return 0;
    }

    if (server->paused)
    {
        response->success = false;
        response->error_message = strdup("Debugger already paused");
        return 0;
    }

    // Parse arguments
    int thread_id = -1;
    cJSON *thread_id_json = cJSON_GetObjectItem(args, "threadId");
    if (thread_id_json && cJSON_IsNumber(thread_id_json))
    {
        thread_id = thread_id_json->valueint;
    }

    // Validate thread ID
    if (thread_id < 0)
    {
        response->success = false;
        response->error_message = strdup("Invalid thread ID");
        return 0;
    }

    // Create response body
    cJSON *body = cJSON_CreateObject();
    if (!body)
    {
        response->success = false;
        response->error_message = strdup("Failed to create response body");
        return 0;
    }

    cJSON_AddBoolToObject(body, "allThreadsStopped", true);

    // Convert to string
    char *body_str = cJSON_PrintUnformatted(body);
    cJSON_Delete(body);
    if (!body_str)
    {
        response->success = false;
        response->error_message = strdup("Failed to format response body");
        return 0;
    }

    // Update debugger state
    server->paused = true;
    server->current_thread_id = thread_id;

    response->success = true;
    response->data = body_str;

    // Send stopped event according to DAP spec

    cJSON *event_body = cJSON_CreateObject();
    if (event_body)
    {
        cJSON_AddStringToObject(event_body, "reason", "pause");
        cJSON_AddNumberToObject(event_body, "threadId", thread_id);
        cJSON_AddBoolToObject(event_body, "allThreadsStopped", true);
        cJSON_AddStringToObject(event_body, "description", "Thread paused by user");

        if (server->current_source)
        {
            cJSON *source = cJSON_CreateObject();
            if (source)
            {
                cJSON_AddStringToObject(source, "name", server->current_source->name);
                cJSON_AddStringToObject(source, "path", server->current_source->path);
                cJSON_AddItemToObject(event_body, "source", source);
            }
        }

        // Add line information if available
        if (server->current_line > 0)
        {
            cJSON_AddNumberToObject(event_body, "line", server->current_line);
            cJSON_AddNumberToObject(event_body, "column", server->current_column);
        }

        dap_server_send_event(server, "stopped", event_body);
        // Remove this line as it causes a double-free - dap_server_send_event already handles freeing the body
        // cJSON_Delete(event_body);
    }

    return 0;
}

// Implement missing handler functions
int handle_configuration_done(DAPServer *server, cJSON *args, DAPResponse *response)
{
    (void)server; // Mark as unused
    (void)args;   // Mark as unused

    if (!response)
        return -1;
    response->success = true;
    response->data = strdup("{}");
    return 0;
}

/**
 * @brief Evaluate an expression in the current context
 *
 * @param args JSON arguments containing the expression to evaluate
 * @param response Response to fill with results
 * @return int 0 on success, error code on failure
 */
int handle_evaluate(DAPServer *server, cJSON *args, DAPResponse *response)
{
    (void)server; // Mark as unused
    if (!args || !response)
        return -1;

    // Extract the expression from arguments
    cJSON *expression = cJSON_GetObjectItem(args, "expression");
    if (!expression || !cJSON_IsString(expression))
    {
        set_response_error(response, "Missing or invalid expression");
        return 0;
    }

    // For mock server, just echo back the expression with a mock evaluation
    cJSON *body = cJSON_CreateObject();
    if (!body)
    {
        set_response_error(response, "Failed to create response body");
        return 0;
    }

    // In a real implementation, this would actually evaluate the expression
    cJSON_AddStringToObject(body, "result", expression->valuestring);
    cJSON_AddStringToObject(body, "type", "string");
    cJSON_AddNumberToObject(body, "variablesReference", 0);

    set_response_success(response, body);
    // body is freed by set_response_success
    return 0;
}

/**
 * @brief Return a list of loaded source files
 *
 * @param args JSON arguments (not used in this implementation)
 * @param response Response to fill with loaded sources
 * @return int 0 on success, error code on failure
 */
int handle_loaded_sources(DAPServer *server, cJSON *args, DAPResponse *response)
{
    (void)args; // Mark as unused
    if (!response)
        return -1;

    // Create mock response with current source file
    cJSON *body = cJSON_CreateObject();
    if (!body)
    {
        set_response_error(response, "Failed to create response body");
        return 0;
    }

    cJSON *sources = cJSON_CreateArray();
    if (!sources)
    {
        cJSON_Delete(body);
        set_response_error(response, "Failed to create sources array");
        return 0;
    }

    // Add current source if available
    if (server->current_source)
    {
        cJSON *source = cJSON_CreateObject();
        if (source)
        {
            cJSON_AddStringToObject(source, "name", server->current_source->name);
            cJSON_AddStringToObject(source, "path", server->current_source->path);
            cJSON_AddNumberToObject(source, "sourceReference", 0);
            cJSON_AddItemToArray(sources, source);
        }
    }

    cJSON_AddItemToObject(body, "sources", sources);
    set_response_success(response, body);
    // body is freed by set_response_success
    return 0;
}

// static int handle_set_variable(cJSON* args, DAPResponse* response) { ... }
// static int handle_set_expression(cJSON* args, DAPResponse* response) { ... }
// static int handle_modules(cJSON* args, DAPResponse* response) { ... }
// static int handle_step_back(cJSON* args, DAPResponse* response) { ... }
// static int handle_set_instruction_breakpoints(cJSON* args, DAPResponse* response) { ... }
// static int handle_set_data_breakpoints(cJSON* args, DAPResponse* response) { ... }
// static int handle_exception_info(cJSON* args, DAPResponse* response) { ... }

int handle_launch(DAPServer *server, cJSON *args, DAPResponse *response)
{
    if (!response || !args)
    {
        DAP_SERVER_DEBUG_LOG("Error: Invalid arguments");
        set_response_error(response, "Invalid arguments");
        return 0;
    }

    DAP_SERVER_DEBUG_LOG("Handling launch request");

    // Get program path from arguments
    cJSON *program = cJSON_GetObjectItem(args, "program");
    if (!program || !cJSON_IsString(program))
    {
        DAP_SERVER_DEBUG_LOG("Error: Missing or invalid program path");
        set_response_error(response, "Missing or invalid program path");
        return 0;
    }

    // Get working directory if specified
    cJSON *cwd = cJSON_GetObjectItem(args, "cwd");
    char *source_path = NULL;
    char *executable_path = NULL;

    if (cwd && cJSON_IsString(cwd))
    {
        if (chdir(cwd->valuestring) != 0)
        {
            DAP_SERVER_DEBUG_LOG("Error: Failed to change working directory to %s: %s",
                                 cwd->valuestring, strerror(errno));
            set_response_error(response, "Failed to change working directory");
            return 0;
        }
        DAP_SERVER_DEBUG_LOG("Changed working directory to %s", cwd->valuestring);
    }

    // Check if the provided path is a source file
    const char *ext = strrchr(program->valuestring, '.');
    bool is_source_file = (ext && (strcmp(ext, ".c") == 0 || strcmp(ext, ".cpp") == 0 ||
                                   strcmp(ext, ".h") == 0 || strcmp(ext, ".hpp") == 0 ||
                                   strcmp(ext, ".cc") == 0 || strcmp(ext, ".hh") == 0));

    if (is_source_file)
    {
        source_path = strdup(program->valuestring);
        // In a real implementation, we would compile the source file
        // For mock server, we'll just use the source file as the program
        executable_path = strdup(program->valuestring);
    }
    else
    {
        executable_path = strdup(program->valuestring);
        source_path = strdup(program->valuestring);
    }

    if (!source_path || !executable_path)
    {
        DAP_SERVER_DEBUG_LOG("Error: Failed to allocate memory for paths");
        set_response_error(response, "Failed to allocate memory for paths");
        free(source_path);
        free(executable_path);
        return 0;
    }

    // Check for stopAtEntry flag
    bool shouldStopAtEntry = true; // Default to stopping at entry
    cJSON *stopAtEntry = cJSON_GetObjectItem(args, "stopOnEntry");
    if (stopAtEntry && cJSON_IsBool(stopAtEntry))
    {
        shouldStopAtEntry = cJSON_IsTrue(stopAtEntry);
    }

    // Get program arguments
    cJSON *args_json = cJSON_GetObjectItem(args, "args");
    cJSON *env = cJSON_GetObjectItem(args, "env");

    // Create success response
    cJSON *body = cJSON_CreateObject();
    if (!body)
    {
        DAP_SERVER_DEBUG_LOG("Error: Failed to create response body");
        set_response_error(response, "Failed to create response body");
        free(source_path);
        free(executable_path);
        return 0;
    }

    cJSON_AddStringToObject(body, "program", executable_path);
    cJSON_AddStringToObject(body, "source", source_path);
    cJSON_AddBoolToObject(body, "stopAtEntry", shouldStopAtEntry);

    // Add optional arguments to response
    if (args_json)
        cJSON_AddItemToObject(body, "args", cJSON_Duplicate(args_json, 1));
    if (env)
        cJSON_AddItemToObject(body, "env", cJSON_Duplicate(env, 1));
    if (cwd)
        cJSON_AddItemToObject(body, "cwd", cJSON_Duplicate(cwd, 1));

    // Set debugger state
    server->is_running = true;
    server->attached = true;
    server->paused = true;

    if (server->program_path)
    {
        free((void *)server->program_path);
    }

    server->program_path = strdup(executable_path);
    if (!server->program_path)
    {
        DAP_SERVER_DEBUG_LOG("Error: Failed to store program path");
        set_response_error(response, "Failed to store program path");
        cJSON_Delete(body);
        free(source_path);
        free(executable_path);
        return 0;
    }

    // Clean up old source info
    if (server->current_source)
    {
        if (server->current_source->path)
        {
            free((void *)server->current_source->path);
        }
        if (server->current_source->name)
        {
            free((void *)server->current_source->name);
        }
        free((void *)server->current_source);
        server->current_source = NULL;
    }

    // Create and set current source information
    DAPSource *source = malloc(sizeof(DAPSource));
    if (source)
    {
        memset(source, 0, sizeof(DAPSource));
        source->path = strdup(source_path);

        // Extract filename from path
        const char *filename = strrchr(source_path, '/');
        if (filename)
        {
            source->name = strdup(filename + 1);
        }
        else
        {
            source->name = strdup(source_path);
        }

        source->presentation_hint = DAP_SOURCE_PRESENTATION_NORMAL;
        source->origin = DAP_SOURCE_ORIGIN_UNKNOWN;

        server->current_source = source;
        server->current_line = 1;   // Start at line 1
        server->current_column = 1; // Start at column 1
    }

    // Set success response
    set_response_success(response, body);
    // body is freed by set_response_success

    DAP_SERVER_DEBUG_LOG("Launch response prepared for program: %s", executable_path);
    DAP_SERVER_DEBUG_LOG("Response success: %s, data: %s",
                         response->success ? "true" : "false",
                         response->data ? response->data : "null");

    // Free allocated memory after it's no longer needed
    free(source_path);
    free(executable_path);

    return 0;
}

int handle_attach(DAPServer *server, cJSON *args, DAPResponse *response)
{
    cJSON *pid = cJSON_GetObjectItem(args, "pid");
    if (!pid || !cJSON_IsNumber(pid))
    {
        response->success = false;
        response->error_message = strdup("Missing or invalid process ID");
        return 0;
    }

    server->is_running = true;
    server->attached = true;
    server->paused = true;

    // Create a proper JSON object instead of using strdup
    cJSON *body = cJSON_CreateObject();
    if (!body) {
        response->success = false;
        response->error_message = strdup("Failed to create response body");
        return 0;
    }
    
    set_response_success(response, body);
    // body is freed by set_response_success
    return 0;
}

int handle_disconnect(DAPServer* server, cJSON* args, DAPResponse* response) {
    (void)server;  // Mark as unused
    (void)args;  // Mark as unused

    cleanup_breakpoints(server);
    printf("Disconnecting from debuggee\n");
    
    // Create a proper JSON object instead of using strdup
    cJSON *body = cJSON_CreateObject();
    if (!body) {
        response->success = false;
        response->error_message = strdup("Failed to create response body");
        return 0;
    }
    
    set_response_success(response, body);
    // body is freed by set_response_success
    return 0;
}

int handle_terminate(DAPServer* server, cJSON* args, DAPResponse* response) {
    (void)server;  // Mark as unused
    (void)args;  // Mark as unused

    printf("Terminating debuggee\n");
    
    // Create a proper JSON object instead of using strdup
    cJSON *body = cJSON_CreateObject();
    if (!body) {
        response->success = false;
        response->error_message = strdup("Failed to create response body");
        return 0;
    }
    
    set_response_success(response, body);
    // body is freed by set_response_success
    return 0;
}


int handle_restart(DAPServer* server, cJSON* args, DAPResponse* response) {
    (void)server;  // Mark as unused
    (void)args;  // Mark as unused

    printf("Restarting debuggee\n");
    
    // Create a proper JSON object instead of using strdup
    cJSON *body = cJSON_CreateObject();
    if (!body) {
        response->success = false;
        response->error_message = strdup("Failed to create response body");
        return 0;
    }
    
    set_response_success(response, body);
    // body is freed by set_response_success
    return 0;
}


/**
 * @brief Handle the setExceptionBreakpoints command
 * 
 * As per the DAP specification:
 * - The setExceptionBreakpoints request configures the debugger's response to thrown exceptions
 * - Each filter tells the debug adapter which kinds of exceptions should cause execution to break
 * - The "filters" argument is an array of exception filter IDs to activate
 * - The "filterOptions" argument provides additional configuration for each filter, like conditions
 * - The response should include a "breakpoints" array with verification status for each filter
 * 
 * @param server The DAP server instance
 * @param args Command arguments as a cJSON object
 * @param response Response structure to fill
 * @return int 0 on success, non-zero on failure
 */
int handle_set_exception_breakpoints(DAPServer *server, cJSON *args, DAPResponse *response) {
    if (!server || !args || !response) {
        return -1;
    }
    
    // "filters" (required) - Array of exception filter IDs to activate
    // These IDs correspond to the filter options returned by the "initialize" response
    // and refer to the ExceptionBreakpointsFilter capabilities provided by the adapter
    cJSON *filters = cJSON_GetObjectItem(args, "filters");
    if (!filters || !cJSON_IsArray(filters)) {
        // Return success with empty breakpoints array instead of an error
        cJSON *body = cJSON_CreateObject();
        if (!body) {
            set_response_error(response, "Failed to create response body");
            return 0;
        }
        
        // According to DAP spec, the response must include a "breakpoints" array
        // even when no filters are specified
        cJSON *breakpoints = cJSON_CreateArray();
        if (!breakpoints) {
            cJSON_Delete(body);
            set_response_error(response, "Failed to create breakpoints array");
            return 0;
        }
        
        cJSON_AddItemToObject(body, "breakpoints", breakpoints);
        set_response_success(response, body);
        cJSON_Delete(body);
        
        // Call the callback with empty filters to clear any existing exception breakpoints
        if (server->set_exception_breakpoints_callback) {
            server->set_exception_breakpoints_callback(
                server, NULL, 0, NULL, 0, server->exception_callback_user_data
            );
        }
        
        return 0;
    }
    
    // "filterOptions" (optional) - Additional configuration for exception filters
    // Contains filterId, condition and other options for exception filters
    // This is only honored if the capability 'supportsExceptionFilterOptions' is true
    cJSON *filter_options = cJSON_GetObjectItem(args, "filterOptions");
    
    // "exceptionOptions" (optional) - Not fully implemented in this handler
    // Used for detailed exception category-specific options
    
    // Count the number of filters in the array
    int filter_count = cJSON_GetArraySize(filters);
    
    // Extract filter IDs into an array
    const char** filter_ids = NULL;
    const char** filter_conditions = NULL;
    
    if (filter_count > 0) {
        filter_ids = calloc(filter_count, sizeof(char*));
        if (!filter_ids) {
            set_response_error(response, "Failed to allocate memory for filter IDs");
            return 0;
        }
        
        // We'll also track conditions if filterOptions is provided
        if (filter_options && cJSON_IsArray(filter_options)) {
            filter_conditions = calloc(filter_count, sizeof(char*));
            if (!filter_conditions) {
                free(filter_ids);
                set_response_error(response, "Failed to allocate memory for filter conditions");
                return 0;
            }
        }
        
        // Extract each filter ID and any matching conditions from filterOptions
        for (int i = 0; i < filter_count; i++) {
            cJSON *filter = cJSON_GetArrayItem(filters, i);
            if (filter && cJSON_IsString(filter)) {
                filter_ids[i] = filter->valuestring;
                
                // Look for matching filter condition if filter_options is provided
                if (filter_conditions && filter_options && cJSON_IsArray(filter_options)) {
                    int option_count = cJSON_GetArraySize(filter_options);
                    for (int j = 0; j < option_count; j++) {
                        cJSON *option = cJSON_GetArrayItem(filter_options, j);
                        if (!option || !cJSON_IsObject(option)) continue;
                        
                        // "filterId" - Matches ID from filters array
                        cJSON *filter_id = cJSON_GetObjectItem(option, "filterId");
                        if (!filter_id || !cJSON_IsString(filter_id)) continue;
                        
                        if (strcmp(filter_id->valuestring, filter->valuestring) == 0) {
                            // Found matching filter option
                            // "condition" - Expression for conditional exception breakpoints
                            // The exception breaks if the condition expression evaluates to true
                            cJSON *condition = cJSON_GetObjectItem(option, "condition");
                            if (condition && cJSON_IsString(condition)) {
                                filter_conditions[i] = condition->valuestring;
                            }
                            break;
                        }
                    }
                }
            }
        }
    }
    
    // Call the callback if it's registered
    int result = 0;
    if (server->set_exception_breakpoints_callback) {
        result = server->set_exception_breakpoints_callback(
            server, 
            filter_ids, 
            filter_count, 
            filter_conditions, 
            filter_conditions ? filter_count : 0,
            server->exception_callback_user_data
        );
    }
    
    // Free allocated memory
    if (filter_ids) {
        free(filter_ids);
    }
    if (filter_conditions) {
        free(filter_conditions);
    }
    
    // If result is non-zero, there was an error
    if (result != 0) {
        set_response_error(response, "Failed to set exception breakpoints");
        return 0;
    }
    
    // Create response with breakpoints array matching filter count
    // Per DAP spec, each filter should correspond to a breakpoint in the response
    cJSON *body = cJSON_CreateObject();
    if (!body) {
        set_response_error(response, "Failed to create response body");
        return 0;
    }
    
    // "breakpoints" array - contains status info for each exception breakpoint filter
    cJSON *breakpoints = cJSON_CreateArray();
    if (!breakpoints) {
        cJSON_Delete(body);
        set_response_error(response, "Failed to create breakpoints array");
        return 0;
    }
    
    // Add one breakpoint object for each filter
    for (int i = 0; i < filter_count; i++) {
        cJSON *breakpoint = cJSON_CreateObject();
        if (!breakpoint) {
            cJSON_Delete(body);
            set_response_error(response, "Failed to create breakpoint object");
            return 0;
        }
        
        // "verified" (required) - Whether the breakpoint is valid and could be set
        cJSON_AddBoolToObject(breakpoint, "verified", true);
        
        // "id" (optional) - Unique identifier for this breakpoint
        // Use base ID of 1000 to differentiate from regular breakpoints
        cJSON_AddNumberToObject(breakpoint, "id", 1000 + i);
        
        // "message" (optional) - Error or information message about the breakpoint
        cJSON *filter = cJSON_GetArrayItem(filters, i);
        if (filter && cJSON_IsString(filter)) {
            char message[128];
            snprintf(message, sizeof(message), "Exception breakpoint: %s", filter->valuestring);
            cJSON_AddStringToObject(breakpoint, "message", message);
        }
        
        // Add the breakpoint to the array
        cJSON_AddItemToArray(breakpoints, breakpoint);
    }
    
    cJSON_AddItemToObject(body, "breakpoints", breakpoints);
    set_response_success(response, body);
    cJSON_Delete(body);
    
    return 0;
}

/**
 * @brief Set multiple capabilities at once
 * 
 * This function accepts a variable number of capability ID and boolean pairs,
 * terminated by DAP_CAP_COUNT. For example:
 * 
 * dap_server_set_capabilities(
 *     DAP_CAP_CONFIG_DONE_REQUEST, true,
 *     DAP_CAP_FUNCTION_BREAKPOINTS, true,
 *     DAP_CAP_CONDITIONAL_BREAKPOINTS, true,
 *     DAP_CAP_COUNT  // Terminator
 * );
 * 
 * @param ... Variable number of DAPCapabilityID and boolean pairs, terminated by DAP_CAP_COUNT
 * @return int The number of capabilities actually set
 */
int dap_server_set_capabilities(DAPServer *server, ...)
{
    (void)server; // Parameter currently unused, but included for future use
    
    va_list args;
    va_start(args, server);
    
    int count = 0;
    DAPCapabilityID capability_id;
    
    while ((capability_id = va_arg(args, DAPCapabilityID)) != DAP_CAP_COUNT) {
        bool supported = va_arg(args, int);  // bool is promoted to int in va_arg
        if (dap_server_set_capability(capability_id, supported) == 0) {
            count++;
        }
    }
    
    va_end(args);
    return count;
}